/*
    Copyright 2010 Semantic Discovery, Inc. (www.semanticdiscovery.com)

    This file is part of the Semantic Discovery Toolkit.

    The Semantic Discovery Toolkit is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The Semantic Discovery Toolkit is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with The Semantic Discovery Toolkit.  If not, see <http://www.gnu.org/licenses/>.
*/
package org.sd.util;


import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.List;
import org.sd.io.FileUtil;

/**
 * Utility class for converting a map to dot (record) format.
 * <p>
 * Dot format is a text file representing a graph that can be turned
 * into an image using AT&amp;T's GraphViz project.
 * <p>
 * For example, the following command will turn a dot (text) file
 * generated by this utility into a png image.
 * <p>
 * dot -Tpng x.dot -o x.png
 *
 * @author Spence Koehler
 */
public class Map2Dot extends DotMaker {
  
  private String header;
  private Map map;

  private List<String> records;
  private List<String> edges;

  public Map2Dot(Map map) {
    this(null, map);
  }

  public Map2Dot(String header, Map map) {
    super();

    this.header = fixRecordString(header);
    this.map = map;

    this.records = new ArrayList<String>();
    this.edges = new ArrayList<String>();

    setGraphAttribute("rankdir", "TB");
    setNodeAttribute("shape", "record");
    setNodeAttribute("fontsize", "8");
  }

  protected void populateEdges() {
    populateEdges(this.header, this.map);
  }

  protected void makeEdges(Writer writer) throws IOException {
    // write record definition lines
    for (String record : records) {
      writer.write("  ");
      writer.write(record);
      writer.write("\n");
    }

    writer.write("\n");

    // write edge lines
    for (String edge : edges) {
      writer.write("  ");
      writer.write(edge);
      writer.write("\n");
    }

    writer.write("\n");
  }

  /**
   * Recursively build a record definition for the map.
   */
  protected String populateEdges(String header, Map map) {
    final StringBuilder nodeString = new StringBuilder();

    final String nodeName = "struct" + getNextId();
    nodeString.append(nodeName).append(" [shape=record,label=\"");

    if (header != null) {
      // add header as "top row" in record
      nodeString.append("{<h> ").append(header);
    }

    int entryNum = 0;
    for (Object mapEntry : map.entrySet()) {
      final Map.Entry entry = (Map.Entry)mapEntry;
      final String key = asString(entry.getKey());
      final Object value = entry.getValue();
      final Map valueMap = (value != null && value instanceof Map) ? (Map)value : null;

      nodeString.
        append("|{").
        append("<k").
        append(entryNum).
        append("> ").
        append(key).
        append(" | ").
        append("<v").
        append(entryNum).
        append("> ").
        append(asString(valueMap != null ? "" : value)).
        append(" }");

      if (valueMap != null) {
        final String destNodeName = populateEdges(key, valueMap);
        edges.add(makeEdge(nodeName, "v" + entryNum, destNodeName, "h"));
      }

      ++entryNum;
    }

    if (header != null) {
      nodeString.append(" }");
    }

    nodeString.append("\"];");

    records.add(nodeString.toString());

    return nodeName;
  }

  private final String makeEdge(String sourceName, String sourceField, String destName, String destField) {
    final StringBuilder result = new StringBuilder();

    result.append(sourceName);
    if (sourceField != null) {
      result.append(':').append(sourceField);
    }

    result.append(" -> ");

    result.append(destName);
    if (destField != null) {
      result.append(':').append(destField);
    }

    result.append(';');

    return result.toString();
  }

  private final String asString(Object value) {
    final String result = (value == null) ? "" : value.toString();
    return fixRecordString(result.toString());
  }


  public static void main(String[] args) throws IOException {

    if (args.length < 2) {
      System.out.println("Usage: Map2Dot outputFile header k1=v1 k2=v2 ...");
    }
    else {
      final LinkedHashMap<String, Object> map = new LinkedHashMap<String, Object>();

      if (args.length == 2) {
        final LinkedHashMap<String, Object> mapA = new LinkedHashMap<String, Object>();
        final LinkedHashMap<String, Object> mapB = new LinkedHashMap<String, Object>();
        final LinkedHashMap<String, Object> mapC = new LinkedHashMap<String, Object>();

        mapA.put("a0", "v0");
        mapA.put("a1", "v1");
        mapA.put("a2", "v2");

        mapB.put("b0", "v0");
        mapB.put("b1", "v1");
        mapB.put("b2", "v2");

        mapC.put("c0", "v0");
        mapC.put("c1", "v1");
        mapC.put("c2", "v2");


        map.put("a", mapA);
        map.put("b", mapB);
        map.put("c", mapC);
      }
      else {
        for (int argNum = 2; argNum < args.length; ++argNum) {
          final String arg = args[argNum];
          final String[] kv = arg.split("\\s*=\\s*");
          map.put(kv[0], kv[1]);
        }
      }
        
      final Map2Dot map2dot = new Map2Dot(args[1], map);
      final Writer writer = org.sd.io.FileUtil.getWriter(args[0]);
      map2dot.writeDot(writer);
      writer.close();
    }
  }
}
